
> (lg "corner" :make t)


=========================== p r e p a r i n g ===============================

Project name: corner
  Input : corner.lisptokens 
  Output: corner.ded 
Check to see if output contains any spec errors.
Fix and re-run if it does.
You can also re/create corner.lisptokens by running 'tokens corner' sed script offline.
======================= l o a d i n g =======================================

Project [corner] is assumed to consist of
-----------------------------------------------------------------------------
  CCG grammar source : corner.ccg $
    Its token form   : corner.lisptokens $
  Deduction grammar  : corner.ded $ (derived from corner.lisptokens)
  Induction grammar  : corner.ind #
  Supervision source : corner.sup ^
  Model-specific code: corner.lisp ^
   and other model-specific files you may create.
       *CCG-GRAMMAR* : set from corner.ded
  *LEX-RULES-TABLE*  : set from corner.ded
Expected files       : $ for deduction, # for induction, ^ for model development
=============================================================================
T
> (tr "corner.ded" '(V))

NIL
> (savetr "corner-raised.ded")

Type-raising rules added at the end of *ccg-grammar*
compiled, subsumed and saved.
NIL
> (lg "corner-raised")

======================= l o a d i n g =======================================

Project [corner-raised] is assumed to consist of
-----------------------------------------------------------------------------
  CCG grammar source : corner-raised.ccg $
    Its token form   : corner-raised.lisptokens $
  Deduction grammar  : corner-raised.ded $ (derived from corner-raised.lisptokens)
  Induction grammar  : corner-raised.ind #
  Supervision source : corner-raised.sup ^
  Model-specific code: corner-raised.lisp ^
   and other model-specific files you may create.
       *CCG-GRAMMAR* : set from corner-raised.ded
  *LEX-RULES-TABLE*  : set from corner-raised.ded
Expected files       : $ for deduction, # for induction, ^ for model development
=============================================================================
T
> (onoff)

*BEAMP* : NIL
*LFFLAG* : T
*NF-PARSE* : T
*OOVP* : NIL
*TYPE-RAISED-P* : NIL
NIL
> (p '(the man hits the boy))

T
> (ders)


Derivation 1
--------------
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (MAN) := N
        : MAN
>     (THE)(MAN) := NP
        : ((LAM X X) MAN)
LEX   (HITS) := (S\NP)/NP
        : (LAM X (LAM Y ((HITS X) Y)))
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (BOY) := N
        : BOY
>     (THE)(BOY) := NP
        : ((LAM X X) BOY)
>     (HITS)(THE BOY) := S\NP
        : ((LAM X (LAM Y ((HITS X) Y))) ((LAM X X) BOY))
<     (THE MAN)(HITS THE BOY) := S
        : (((LAM X (LAM Y ((HITS X) Y))) ((LAM X X) BOY)) ((LAM X X) MAN))

Final LF, normal-order evaluated: 

    ((HITS BOY) MAN) =
    (HITS BOY MAN)

Derivation 2
--------------
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (BOY) := N
        : BOY
>     (THE)(BOY) := NP
        : ((LAM X X) BOY)
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (MAN) := N
        : MAN
>     (THE)(MAN) := NP
        : ((LAM X X) MAN)
LEX   (HITS) := (S\NP)/NP
        : (LAM X (LAM Y ((HITS X) Y)))
_MLU388 (THE BOY) := (S\NP)\((S\NP)/NP)
        : ((LAM LF (LAM P (P LF))) ((LAM X X) BOY))
<     (HITS)(THE BOY) := S\NP
        : (((LAM LF (LAM P (P LF))) ((LAM X X) BOY))
           (LAM X (LAM Y ((HITS X) Y))))
<     (THE MAN)(HITS THE BOY) := S
        : ((((LAM LF (LAM P (P LF))) ((LAM X X) BOY))
            (LAM X (LAM Y ((HITS X) Y))))
           ((LAM X X) MAN))

Final LF, normal-order evaluated: 

    ((HITS BOY) MAN) =
    (HITS BOY MAN)

Derivation 3
--------------
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (MAN) := N
        : MAN
>     (THE)(MAN) := NP
        : ((LAM X X) MAN)
_MLU386 (THE MAN) := S/(S\NP)
        : ((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
LEX   (HITS) := (S\NP)/NP
        : (LAM X (LAM Y ((HITS X) Y)))
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (BOY) := N
        : BOY
>     (THE)(BOY) := NP
        : ((LAM X X) BOY)
>     (HITS)(THE BOY) := S\NP
        : ((LAM X (LAM Y ((HITS X) Y))) ((LAM X X) BOY))
>     (THE MAN)(HITS THE BOY) := S
        : (((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
           ((LAM X (LAM Y ((HITS X) Y))) ((LAM X X) BOY)))

Final LF, normal-order evaluated: 

    ((HITS BOY) MAN) =
    (HITS BOY MAN)

Derivation 4
--------------
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (MAN) := N
        : MAN
>     (THE)(MAN) := NP
        : ((LAM X X) MAN)
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (BOY) := N
        : BOY
>     (THE)(BOY) := NP
        : ((LAM X X) BOY)
_MLU386 (THE MAN) := S/(S\NP)
        : ((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
LEX   (HITS) := (S\NP)/NP
        : (LAM X (LAM Y ((HITS X) Y)))
_MLU388 (THE BOY) := (S\NP)\((S\NP)/NP)
        : ((LAM LF (LAM P (P LF))) ((LAM X X) BOY))
<     (HITS)(THE BOY) := S\NP
        : (((LAM LF (LAM P (P LF))) ((LAM X X) BOY))
           (LAM X (LAM Y ((HITS X) Y))))
>     (THE MAN)(HITS THE BOY) := S
        : (((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
           (((LAM LF (LAM P (P LF))) ((LAM X X) BOY))
            (LAM X (LAM Y ((HITS X) Y)))))

Final LF, normal-order evaluated: 

    ((HITS BOY) MAN) =
    (HITS BOY MAN)

Try (cky-pprint) to see the details including the features and slash modalities.
    (cky-reveal-cell <cell>) to pretty-print the parse in <cell>.
NIL
> (status)


  do (rules) or (onoff) for rules and switches
  ---------------------------
  Any non-standard rule     ? NO
  Currently loaded grammar  : corner-raised.ded
 *CCG-GRAMMAR*              : 15 items
 *LEX-RULES-TABLE*          : 4 items
 *CKY-HASHTABLE*            : 20 items
 *CKY-INPUT* for the table  : (THE MAN HITS THE BOY) 
  Most likely LF w/weight   : NIL 
  Its most likely derivation: NIL
  Sum of weighted counts    : 0.0 
  Most likely LF's cells    : NIL 
  Number of differing LFs   : 0 
  Most weighted derivation  : NIL 
  ---------------------------
NIL
> (dribble)
